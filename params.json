{"body":"# EMBED IMAGE\r\n\r\nThere are several approaches that could be taken in order to encode a message into an image. Here, we will be looking at a very clean approach which doesn't add additional bits onto the image - ie. the image size remains exactly the same. This means, it's very difficult for other applications to notice that the image has actually be tampered with. Here is the logic behind the Encode Message application:\r\n\r\nA 24 bit image means that we are dealing with 3 bytes per pixel - 1 Red byte, 1 Green byte, and 1 Blue byte. The lower bits in a pixel are actually mostly considered 'white noise.' This means that manipulating these values will create little to no difference to the common viewer. In fact, most people won't be able to notice any difference at all.\r\n\r\nThese are the bit masks which were used in order to deal with the bits within each byte of colour For blue and red we will be replacing the 3 least significant bits, while for green, we'll be replacing the 2 least significant bits. This allows us to store 1 byte of data per pixel (each pixel is 3 bytes large). The value masks can be thought of as placeholders – they indicate where in the byte we will be storing the data/message.\r\n\r\n\r\n\r\n## Pseudo-Code: Algorithm Code Samples and Implementation Discussion\r\n\r\n### Private Class Variables - The Masks\r\n\r\n       //11111000\r\n       private const byte BlueMask = 248;\r\n\r\n       //11111100\r\n       private const byte GreenMask = 252;\r\n\r\n       //11111000\r\n       private const byte RedMask = 248;\r\n\r\n       //11100000\r\n       private const byte BValueMask = 224;\r\n\r\n       //00011000\r\n       private const byte GValueMask = 24;\r\n\r\n       //00000111\r\n       private const byte RValueMask = 7;\r\n\r\n      // 00000111\r\n      private const byte InverseBlueMask = 7; \r\n\r\n      // 00000011\r\n      private const byte InverseGreenMask = 3;\r\n\r\n      // 00000111\r\n      private const byte InverseRedMask = 7;\r\n\r\n### Embedding The Message\r\n\r\n    public byte changeEachBit(byte byteToManipulate, int colour, byte theMessage)\r\n    {\r\nThis method will be passed the byte which we are going to manipulate(Red byte, Green byte,\r\nor Blue byte), the colour as an int (for indicating which colour we are dealing with) as well as the byte message which we will be distributing throughout the Red byte, Green byte, and Blue byte.\r\n\r\n      byte value = 0;\r\n      byte returnByte = 0; \r\n\r\n      if (colour == BLUE)\r\n      {\r\nANDing the message with the appropriate mask will zero out the bits which are unimportant to us, indicating the bits which we want to distribute in a specific byte (either red byte, green byte, or blue byte – in this case the blue byte).\r\n\r\n       value= (byte)(theMessage & BValueMask);\r\n\r\nOnce we have the bits in the image, we need extract those specific bits. In this case, we want to shift left in order to get the 3 least significant bits in the message to distribute in the blue byte.\r\n\r\n       value = (byte)(value>>5); \r\n\r\nNow, we can take the byte which we are going to manipulate (red, green or blue byte) and AND it with the appropriate mask – this will isolate or zeroed out the area for us so we are able to place the bits from the message, which we extracted earlier, into the zeroed out area.\r\n\r\n       returnByte = (byte)(byteToManipulate & BlueMask);\r\n\r\nwe now OR the byte (which has the least 3 significant digits zeroed out with the value which holds the 3 bits of the message we want to replace the Zeros out bits with. This process will be repeated for all three bytes of\r\ncolour. Red will not require bit shifting as it is FIRST in order (RED,GREEN, BLUE). Green will only require 2 bits to be zeroed out and replaced with the message – rather than 3 – which is the case for both blue and red bytes.\r\n\r\n       returnByte = (byte)(returnByte | value); \r\n\r\n       }\r\n       else if (colour == GREEN)\r\n       {\r\n           value = (byte)(theMessage & GValueMask);\r\n           value = (byte)(value >> 3);\r\n           returnByte = (byte)(byteToManipulate & GreenMask);\r\n           returnByte = (byte)(returnByte | value);\r\n\r\n       }\r\n       else if (colour == RED)\r\n       {\r\n            value = (byte)(theMessage & RValueMask);\r\n            returnByte = (byte)(byteToManipulate & RedMask);\r\n            returnByte = (byte)(returnByte | value);\r\n       }\r\n\r\n        return returnByte;\r\n      }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n### Retrieving The Message\r\n     public void getEachBitOfMessage(byte byteToManipulate, int colour)\r\n     {\r\nThis method will take in the byte which we are going to extract the bits of the message from as well as the colour of the byte – so we know which byte we're dealing with. byte value = 0;\r\n\r\nIf we have read in 3 bytes (making up one pixel of colour, then we will put all the bits we received from 1 pixel (3 bytes) into a single byte. Once this is done, we will convert that single byte into a value which can be read and understood.\r\n\r\n        if (countToByte == 3)\r\n        {\r\n            byte blueAreaInTotal = 0;\r\n            byte greenAreaInTotal = 0;\r\n            byte redAreaInTotal = 0;\r\n            byte total = 0; \r\n\r\nHere, we make all the appropriate shifts in order to extract the bits we placed within each colour byte. If it is red, no shift is needed as it comes first, if it is green, we shift 3 bits along (we replaced 3 bits of Red, 2 bits of green, and 3 bits of blue). If it’s blue, we shift 5 bits in order to get the last three bits.\r\n\r\n            redAreaInTotal = (byte)(redCount);\r\n            blueAreaInTotal = (byte)(blueCount << 5);\r\n            greenAreaInTotal = (byte)(greenCount << 3);\r\n\r\nIn order to put all bits received from all three colours together into one byte, we must OR each of the bit values received from each byte colour with an empty byte. This will yield us a byte which contains one byte of the message (in other words – one char).\r\n\r\n            total = (byte)(total | redAreaInTotal); \r\n            total = (byte)(total | blueAreaInTotal);\r\n            total = (byte)(total | greenAreaInTotal);\r\n\r\nWe store the char into a list. we do this because storing it into a string is very inefficient and will slow the entire program down as this copy occurs several times. In C# strings are immutable, meaning the string will be destroyed and re-created each time it needs to be modified. This is very costly. Using a list helps to alleviate this cost. Although, there is another way around this :)\r\n\r\n            char val = Convert.ToChar(total);\r\n            String nextChar = val.ToString();\r\n            finalMessage.Add(nextChar);\r\n\r\n            redCount = 0;\r\n            blueCount = 0;\r\n            greenCount = 0; \r\n            countToByte = 0; \r\n        }\r\n\r\n        if (colour == BLUE)\r\n        {\r\n\r\nIn each of these if/else portions, we AND the byte we’re extracting the bits of the message from with the INVERSE of the original mask. This will zero out everything in the byte except for the bits of the message. we do this for all three bytes of colour.\r\n\r\n            value = (byte)(byteToManipulate & InverseBlueMask);\r\n            blueCount = value; \r\n        }\r\n        else if (colour == GREEN)\r\n        {\r\n            value = (byte)(byteToManipulate & InverseGreenMask);\r\n            greenCount = value; \r\n\r\n        }\r\n        else if (colour == RED)\r\n        {\r\n            value = (byte)(byteToManipulate & InverseRedMask);\r\n            redCount = value; \r\n        }\r\n\r\n        countToByte++; \r\n    }\r\n\r\n\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n` `\r\n\r\n[Back](http://tkurian-programming.blogspot.ca/p/encoding-message-into-image.html)","google":"","tagline":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"A.little.code.embedimage"}